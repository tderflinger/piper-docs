---
title: config.py
description: config.py
---

## Code Explained

The provided code defines a Python class, `PiperConfig`, which encapsulates the configuration for a text-to-speech (TTS) system. The class is decorated with `@dataclass`, a feature introduced in Python 3.7 that simplifies the creation of classes by automatically generating boilerplate code such as the `__init__` method, `__repr__`, and others. This makes the class concise and focused on its purpose: storing configuration data.

The `PiperConfig` class contains several attributes, each representing a specific aspect of the TTS system's configuration. For example, `num_symbols` specifies the number of phonemes (symbols used in speech synthesis), while `num_speakers` indicates the number of speakers supported by the model. The `sample_rate` attribute defines the audio sample rate, which determines the quality of the synthesized audio. The `espeak_voice` attribute specifies the name of the `espeak-ng` voice or alphabet used for phonemization, which is the process of converting text into phonemes.

Additional attributes such as `length_scale`, `noise_scale`, and `noise_w` control various aspects of the audio synthesis process. These parameters influence the duration of phonemes, the amount of noise in the generated audio, and the variation in pitch, respectively. The `phoneme_id_map` attribute is a mapping that associates phonemes (strings) with their corresponding numerical IDs, which are used by the TTS model. The `phoneme_type` attribute specifies the type of phonemes being used, such as those generated by `espeak` or plain text.

The class also includes a static method, `from_dict`, which provides a convenient way to create a `PiperConfig` instance from a dictionary. This method extracts configuration values from the dictionary, including nested structures like the `audio` and `inference` sections. Default values are provided for some parameters, such as `noise_scale`, `length_scale`, and `noise_w`, ensuring that the method can handle incomplete configurations gracefully. The `phoneme_type` is converted into an instance of the `PhonemeType` enumeration, which likely defines valid phoneme types (e.g., `ESPEAK`).

Overall, the `PiperConfig` class serves as a structured and extensible way to manage the configuration of a TTS system. By using a dataclass and a static factory method, it ensures that the configuration is easy to initialize, validate, and use throughout the application. This design promotes clarity and maintainability, making it well-suited for complex systems like TTS pipelines.

## Source Code

```py
"""Piper configuration"""
from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, Mapping, Sequence


class PhonemeType(str, Enum):
    ESPEAK = "espeak"
    TEXT = "text"


@dataclass
class PiperConfig:
    """Piper configuration"""

    num_symbols: int
    """Number of phonemes"""

    num_speakers: int
    """Number of speakers"""

    sample_rate: int
    """Sample rate of output audio"""

    espeak_voice: str
    """Name of espeak-ng voice or alphabet"""

    length_scale: float
    noise_scale: float
    noise_w: float

    phoneme_id_map: Mapping[str, Sequence[int]]
    """Phoneme -> [id,]"""

    phoneme_type: PhonemeType
    """espeak or text"""

    @staticmethod
    def from_dict(config: Dict[str, Any]) -> "PiperConfig":
        inference = config.get("inference", {})

        return PiperConfig(
            num_symbols=config["num_symbols"],
            num_speakers=config["num_speakers"],
            sample_rate=config["audio"]["sample_rate"],
            noise_scale=inference.get("noise_scale", 0.667),
            length_scale=inference.get("length_scale", 1.0),
            noise_w=inference.get("noise_w", 0.8),
            #
            espeak_voice=config["espeak"]["voice"],
            phoneme_id_map=config["phoneme_id_map"],
            phoneme_type=PhonemeType(config.get("phoneme_type", PhonemeType.ESPEAK)),
        )
```